











<img src="D:\Zhaoyong's Documents\图片\Njust.jpg" alt="Njust" style="zoom:55%;" />





# 基于LMI的控制系统分析与设计—6.1  线性系统状态观测

<div align = "center">Zhaoyong Liu, School of Automation, NJUST</div>

<div align = "center">October 17, 2023</div>

















<div STYLE=“page-break-after: always;”></div

## 6.1.1  系统描述

考虑如下模型
$$
\left\{\begin{array}{l}
\dot{x}_1=x_2\\
\dot{x_2}=u\\
y=x_1
\end{array}
\right.
$$

其中，$x=[x_1\ \  x_2]^T$

设计观测器，实现  $\hat{x}\rightarrow x$。



## 6.1.2  观测器设计与分析

将上述模型写为状态方程为
$$
\begin{array}{l}
\dot{x}=Ax+Bu\\
y=Cx
\end{array}\tag{1}
$$




## 6.1.3  仿真实例

观测器初始状态取  $\hat{x}(0)=[0\ \  0]$，被控对象初始状态取 $x(0)=[1.0\ \  0]$。运行 LMI 求解程序 chap6_1LMI.m ，可得观测器增益 $L=[0.9779\ \ 1.3371]^T$，仿真结果如图-1 和图-2 所示。

<div>			
    <center>	
    <img src="D:\Typora\Documents\自动控制\初级控制理论\基于LMI的控制系统分析与设计\Chap6_状态观测器设计\figure\chap6_1状态观测.jpg"
         alt="无法显示图片时显示的文字"
         width="80%"
         style="zoom:"/>
    <br>		
    图-1 &nbsp 状态观测结果	
    </center>
</div>

<div>			
    <center>	
    <img src="D:\Typora\Documents\自动控制\初级控制理论\基于LMI的控制系统分析与设计\Chap6_状态观测器设计\figure\chap6_1状态观测误差.jpg"
         alt="无法显示图片时显示的文字"
         width="80%"
         style="zoom:"/>
    <br>		
    图-2 &nbsp 状态观测误差	
    </center>
</div>






仿真程序如下：

（1）求解LMI程序：chap6_1LMI.m

```
%%
clc; clearvars 
LMIs=2; % the number of LMIs
A=[0 1;0 0]; 
B=[0 1]';
C=[1 0];
[dimp,dimn]=size(C);
alpha=3;  % parameter

%%
setlmis([]) 
r = lmivar(1,[dimn 1]); % define variable R
q = lmivar(2,[dimn dimp]); 
%%
lmiterm([1 1 1 r],1,A,'s'); % LMI #1
lmiterm([1 1 1 q],-1,C,'s');
lmiterm([1 1 1 0],alpha);
%%
lmiterm([-2 1 1 r],1,1); % LMI #2

%% Solving LMIs
lmis = getlmis;
% [tmin,xfeas] = feasp(lmis,[0,0,10,0,0],0); % solving with function "feasp"
[tmin,xfeas] = feasp(lmis);
R = dec2mat(lmis,xfeas,r); % exporting feasible value of matrix variable from "xfeas" using "dec2mat"
Q = dec2mat(lmis,xfeas,q);
L = R^-1*Q;
disp('L = ');disp(L);
```

（2）主程序：main.m

```
%%
clc; clear; 
close all;

%% Initialization parameters
h = 0.01;  % step size
t0=0;tf=20;   
x0 = [1; 0];  % initial state
xhat0 = [0; 0];

%% State trajectories of system and observer
[t,x,xhat]=state_obv(@sys_func,[t0 tf],x0,xhat0,h);  

%% Plot
figure(1)
subplot(2,1,1)
plot(t,x(1,:),'k',t,xhat(1,:),'r--','Linewidth',1.3)
legend('$x_1$','$\hat{x}_1$','Interpreter','Latex','Fontsize',14)
xlabel('time (s)')
axis([-inf inf -inf 25])
set(gca,'Linewidth',1,'Fontsize',11)
subplot(2,1,2)
plot(t,x(2,:),'k',t,xhat(2,:),'r--','Linewidth',1.3)
legend('$x_2$','$\hat{x}_2$','Interpreter','Latex','Fontsize',14)
xlabel('time (s)')
axis([-inf inf -inf 2.5])
set(gca,'Linewidth',1,'Fontsize',11)

figure(2)
subplot(2,1,1)
plot(t,x(1,:)-xhat(1,:),'k','Linewidth',1.3)
axis([-inf inf -0.5 1])
legend('$\tilde{x}_1$','Interpreter','Latex','Fontsize',14)
xlabel('time (s)')
set(gca,'Linewidth',1,'Fontsize',11)
subplot(2,1,2)
plot(t,x(2,:)-xhat(2,:),'k','Linewidth',1.3)
axis([-inf inf -0.8 0.2])
legend('$\tilde{x}_2$','Interpreter','Latex','Fontsize',14)
xlabel('time (s)')
set(gca,'Linewidth',1,'Fontsize',11)
```

（3）状态观测程序：state_obv.m

```
%% Forward euler method for solving differential equations

function [t,x,xhat]=state_obv(sys_func,tspan,x0,xhat0,h)
% Input arguments: function name, time span, initial state, observer's initial state,step size
% Output arguments: time, state, observer's state

t0=tspan(1);
tf=tspan(2);
n=floor((tf-t0)/h); 

t=zeros(1,n+1);t(1)=t0;  
x=zeros(2,n+1);x(:,1)=x0;  
xhat=zeros(2,n+1);xhat(:,1)=xhat0;   

for i=1:n
    t(i+1)=t(i)+h;
    [dx, dxhat]= sys_func(t(i),x(:,i),xhat(:,i));
    x(:,i+1)=x(:,i)+h*dx;  
    xhat(:,i+1)=xhat(:,i)+h*dxhat;
end
```

（4）微分方程程序：sys_func.m

```
%% Differential equations

function [dx, dxhat]= sys_func(t,x,xhat)
% Input arguments: state, observer's state
% Output arguments: derivative of x, derivative of xhat

A=[0 1;0 0]; 
B=[0 1]';
C=[1 0];
L=[0.9779 1.3371]';

y=C*x;
yhat=C*xhat;
u=sin(t);  % system input

dx=A*x+B*u; 
dxhat=A*xhat+B*u+L*(y-yhat);
```





[1]  刘金琨. 基于LMI的控制系统设计、分析及MATLAB仿真[M]. 北京：清华大学出版社，2020.
